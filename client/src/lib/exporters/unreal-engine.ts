/**
 * Unreal Engine Data Asset Exporter
 * 
 * Exports tokens as Unreal Engine C++ header and source for a UDataAsset subclass.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, toPascalCase, sanitizeJsName, parseColor, dimensionToPx } from '../token-pipeline';

export const exportUnrealEngine: ExporterDefinition = {
  id: 'unreal-engine',
  name: 'Unreal Engine',
  description: 'C++ DataAsset for Unreal Engine 5 UI and styling.',
  category: 'game-engine',
  extension: 'h',
  mimeType: 'text/x-c++hdr',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'includeSource',
      label: 'Include .cpp implementation',
      type: 'boolean',
      default: false,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const className = 'U' + toPascalCase(sanitizeJsName(tokens.name)) + 'Theme';
    const guard = `${sanitizeJsName(tokens.name).toUpperCase()}_THEME_H`;
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// Unreal Engine 5 DataAsset`,
      '',
      `#pragma once`,
      '',
      `#include "CoreMinimal.h"`,
      `#include "Engine/DataAsset.h"`,
      `#include "${className}.generated.h"`,
      '',
      `/**`,
      ` * Design token theme data asset`,
      ` * Generated from Visual DNA style: ${tokens.name}`,
      ` */`,
      `UCLASS(BlueprintType)`,
      `class ${className} : public UDataAsset`,
      `{`,
      `    GENERATED_BODY()`,
      '',
      `public:`,
    ];
    
    const colorTokens = tokens.groups.color;
    if (colorTokens.length > 0) {
      lines.push('    // Colors');
      for (const token of colorTokens) {
        const propName = toPascalCase(token.path.join('_'));
        if (typeof token.value === 'string') {
          const parsed = parseColor(token.value);
          if (parsed) {
            if (token.description) {
              lines.push(`    /** ${token.description} */`);
            }
            lines.push(`    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Colors")`);
            lines.push(`    FLinearColor ${propName} = FLinearColor(${(parsed.r/255).toFixed(4)}f, ${(parsed.g/255).toFixed(4)}f, ${(parsed.b/255).toFixed(4)}f, ${parsed.a.toFixed(4)}f);`);
            lines.push('');
          }
        }
      }
    }
    
    const dimensionTokens = [...tokens.groups.dimension, ...tokens.groups.spacing];
    if (dimensionTokens.length > 0) {
      lines.push('    // Dimensions');
      for (const token of dimensionTokens) {
        const propName = toPascalCase(token.path.join('_'));
        const px = dimensionToPx(token.value);
        if (!isNaN(px)) {
          if (token.description) {
            lines.push(`    /** ${token.description} */`);
          }
          lines.push(`    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Dimensions")`);
          lines.push(`    float ${propName} = ${px.toFixed(2)}f;`);
          lines.push('');
        }
      }
    }
    
    const typographyTokens = tokens.groups.typography;
    if (typographyTokens.length > 0) {
      lines.push('    // Typography');
      for (const token of typographyTokens) {
        const propName = toPascalCase(token.path.join('_'));
        if (token.type === 'fontFamily') {
          lines.push(`    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Typography")`);
          lines.push(`    FString ${propName} = TEXT("${token.value}");`);
          lines.push('');
        }
      }
    }
    
    lines.push('    // Utility functions');
    lines.push(`    UFUNCTION(BlueprintCallable, Category = "Theme")`);
    lines.push(`    FSlateColor GetSlateColor(const FLinearColor& Color) const`);
    lines.push('    {');
    lines.push('        return FSlateColor(Color);');
    lines.push('    }');
    
    lines.push('};');
    
    return lines.join('\n');
  },
};
