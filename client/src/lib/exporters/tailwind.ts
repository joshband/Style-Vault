/**
 * Tailwind Config Exporter
 * 
 * Exports tokens as Tailwind CSS configuration.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { sanitizeJsName, dimensionToPx } from '../token-pipeline';

export const exportTailwind: ExporterDefinition = {
  id: 'tailwind',
  name: 'Tailwind CSS',
  description: 'Theme configuration for Tailwind CSS. Add to tailwind.config.js theme.extend.',
  category: 'web',
  extension: 'js',
  mimeType: 'text/javascript',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'format',
      label: 'Config format',
      type: 'select',
      default: 'extend',
      options: [
        { value: 'extend', label: 'theme.extend (merge)' },
        { value: 'full', label: 'Full theme (replace)' },
      ],
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const format = options?.format ?? 'extend';
    
    const colors = buildColorObject(tokens.groups.color);
    const spacing = buildSpacingObject(tokens.groups.spacing, tokens.groups.dimension);
    const typography = buildTypographyObject(tokens.groups.typography);
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// Add this to your tailwind.config.js`,
      '',
    ];
    
    if (format === 'extend') {
      lines.push('module.exports = {');
      lines.push('  theme: {');
      lines.push('    extend: {');
    } else {
      lines.push('module.exports = {');
      lines.push('  theme: {');
    }
    
    if (Object.keys(colors).length > 0) {
      lines.push(`      colors: ${formatJsObject(colors, 3)},`);
    }
    
    if (Object.keys(spacing).length > 0) {
      lines.push(`      spacing: ${formatJsObject(spacing, 3)},`);
    }
    
    if (typography.fontFamily && Object.keys(typography.fontFamily).length > 0) {
      lines.push(`      fontFamily: ${formatJsObject(typography.fontFamily, 3)},`);
    }
    
    if (typography.fontSize && Object.keys(typography.fontSize).length > 0) {
      lines.push(`      fontSize: ${formatJsObject(typography.fontSize, 3)},`);
    }
    
    if (format === 'extend') {
      lines.push('    },');
    }
    lines.push('  },');
    lines.push('};');
    
    return lines.join('\n');
  },
};

function buildColorObject(colorTokens: NormalizedTokenSet['tokens']): Record<string, any> {
  const colors: Record<string, any> = {};
  
  for (const token of colorTokens) {
    let current = colors;
    
    for (let i = 0; i < token.path.length - 1; i++) {
      const key = sanitizeJsName(token.path[i]);
      if (!current[key]) {
        current[key] = {};
      }
      current = current[key];
    }
    
    const finalKey = sanitizeJsName(token.path[token.path.length - 1]);
    if (typeof token.value === 'string') {
      current[finalKey] = token.value;
    }
  }
  
  return colors;
}

function buildSpacingObject(
  spacingTokens: NormalizedTokenSet['tokens'],
  dimensionTokens: NormalizedTokenSet['tokens']
): Record<string, string> {
  const spacing: Record<string, string> = {};
  const allTokens = [...spacingTokens, ...dimensionTokens];
  
  for (const token of allTokens) {
    const key = sanitizeJsName(token.path.join('-'));
    const value = token.value;
    
    if (typeof value === 'string' || typeof value === 'number') {
      const px = dimensionToPx(value);
      if (!isNaN(px)) {
        spacing[key] = `${px}px`;
      }
    }
  }
  
  return spacing;
}

function buildTypographyObject(typographyTokens: NormalizedTokenSet['tokens']): {
  fontFamily: Record<string, string[]>;
  fontSize: Record<string, string>;
} {
  const result = {
    fontFamily: {} as Record<string, string[]>,
    fontSize: {} as Record<string, string>,
  };
  
  for (const token of typographyTokens) {
    const key = sanitizeJsName(token.path.join('-'));
    
    if (token.type === 'fontFamily') {
      result.fontFamily[key] = [String(token.value)];
    } else if (token.type === 'dimension' || token.path.some(p => p.toLowerCase().includes('size'))) {
      result.fontSize[key] = String(token.value);
    }
  }
  
  return result;
}

function formatJsObject(obj: any, indent: number): string {
  if (obj === null) return 'null';
  if (typeof obj !== 'object') {
    if (typeof obj === 'string') return `"${obj.replace(/"/g, '\\"')}"`;
    return String(obj);
  }
  
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]';
    const items = obj.map(item => formatJsObject(item, indent + 1));
    return `[${items.join(', ')}]`;
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) return '{}';
  
  const pad = '  '.repeat(indent + 1);
  const closePad = '  '.repeat(indent);
  
  const lines = entries.map(([key, value]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
    return `${pad}${safeKey}: ${formatJsObject(value, indent + 1)}`;
  });
  
  return `{\n${lines.join(',\n')}\n${closePad}}`;
}
