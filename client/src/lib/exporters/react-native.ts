/**
 * React Native Theme Exporter
 * 
 * Exports tokens as React Native StyleSheet-compatible theme.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, toPascalCase, sanitizeJsName, dimensionToPx } from '../token-pipeline';

export const exportReactNative: ExporterDefinition = {
  id: 'react-native',
  name: 'React Native',
  description: 'Theme module for React Native with StyleSheet-compatible values.',
  category: 'mobile',
  extension: 'ts',
  mimeType: 'text/typescript',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'includeStyleSheet',
      label: 'Include StyleSheet example',
      type: 'boolean',
      default: true,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const includeStyleSheet = options?.includeStyleSheet ?? true;
    const themeName = toCamelCase(sanitizeJsName(tokens.name)) || 'theme';
    const typeName = toPascalCase(sanitizeJsName(tokens.name)) + 'Theme';
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// React Native compatible theme`,
      '',
      "import { StyleSheet } from 'react-native';",
      '',
    ];
    
    const colors: Record<string, string> = {};
    for (const token of tokens.groups.color) {
      const key = toCamelCase(token.path.join('_'));
      if (typeof token.value === 'string') {
        colors[key] = token.value;
      }
    }
    
    const spacing: Record<string, number> = {};
    for (const token of [...tokens.groups.spacing, ...tokens.groups.dimension]) {
      const key = toCamelCase(token.path.join('_'));
      const px = dimensionToPx(token.value);
      if (!isNaN(px)) {
        spacing[key] = px;
      }
    }
    
    const typography: Record<string, any> = {};
    for (const token of tokens.groups.typography) {
      const key = toCamelCase(token.path.join('_'));
      if (token.type === 'fontFamily') {
        typography[key] = String(token.value);
      }
    }
    
    lines.push(`export const ${themeName} = {`);
    lines.push(`  colors: ${formatRNObject(colors, 2)},`);
    lines.push(`  spacing: ${formatRNObject(spacing, 2)},`);
    if (Object.keys(typography).length > 0) {
      lines.push(`  typography: ${formatRNObject(typography, 2)},`);
    }
    lines.push('} as const;');
    lines.push('');
    lines.push(`export type ${typeName} = typeof ${themeName};`);
    lines.push('');
    
    if (includeStyleSheet) {
      lines.push('// Example usage with StyleSheet');
      lines.push('export const baseStyles = StyleSheet.create({');
      lines.push('  container: {');
      if (Object.keys(spacing).length > 0) {
        const firstSpacing = Object.keys(spacing)[0];
        lines.push(`    padding: ${themeName}.spacing.${firstSpacing},`);
      }
      if (Object.keys(colors).length > 0) {
        const bgColor = Object.keys(colors).find(k => k.toLowerCase().includes('background')) || Object.keys(colors)[0];
        lines.push(`    backgroundColor: ${themeName}.colors.${bgColor},`);
      }
      lines.push('  },');
      lines.push('  text: {');
      if (Object.keys(colors).length > 0) {
        const textColor = Object.keys(colors).find(k => k.toLowerCase().includes('text') || k.toLowerCase().includes('foreground')) || Object.keys(colors)[0];
        lines.push(`    color: ${themeName}.colors.${textColor},`);
      }
      if (Object.keys(typography).length > 0) {
        const font = Object.keys(typography)[0];
        lines.push(`    fontFamily: ${themeName}.typography.${font},`);
      }
      lines.push('  },');
      lines.push('});');
    }
    
    lines.push('');
    lines.push(`export default ${themeName};`);
    
    return lines.join('\n');
  },
};

function formatRNObject(obj: Record<string, any>, indent: number): string {
  const entries = Object.entries(obj);
  if (entries.length === 0) return '{}';
  
  const pad = '  '.repeat(indent + 1);
  const closePad = '  '.repeat(indent);
  
  const lines = entries.map(([key, value]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
    const formattedValue = typeof value === 'string' ? `"${value}"` : String(value);
    return `${pad}${safeKey}: ${formattedValue}`;
  });
  
  return `{\n${lines.join(',\n')}\n${closePad}}`;
}
