/**
 * JUCE C++ Header Exporter
 * 
 * Exports tokens as C++ header file for JUCE audio applications.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toSnakeCase, toPascalCase, sanitizeJsName, parseColor, dimensionToPx } from '../token-pipeline';

export const exportJUCE: ExporterDefinition = {
  id: 'juce',
  name: 'JUCE (C++)',
  description: 'C++ header file for JUCE audio plugin and application development.',
  category: 'code',
  extension: 'h',
  mimeType: 'text/x-c++hdr',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'useNamespace',
      label: 'Wrap in namespace',
      type: 'boolean',
      default: true,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const useNamespace = options?.useNamespace ?? true;
    const namespace = toPascalCase(sanitizeJsName(tokens.name)) || 'Theme';
    const guard = `${toSnakeCase(tokens.name).toUpperCase()}_THEME_H`;
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// JUCE compatible theme header`,
      '',
      `#ifndef ${guard}`,
      `#define ${guard}`,
      '',
      '#include <JuceHeader.h>',
      '',
    ];
    
    if (useNamespace) {
      lines.push(`namespace ${namespace} {`);
      lines.push('');
    }
    
    const colorTokens = tokens.groups.color;
    if (colorTokens.length > 0) {
      lines.push('// Colors');
      for (const token of colorTokens) {
        const cppName = 'k' + toPascalCase(token.path.join('_'));
        if (typeof token.value === 'string') {
          const parsed = parseColor(token.value);
          if (parsed) {
            const hex = Math.round(parsed.a * 255).toString(16).padStart(2, '0') +
                       Math.round(parsed.r).toString(16).padStart(2, '0') +
                       Math.round(parsed.g).toString(16).padStart(2, '0') +
                       Math.round(parsed.b).toString(16).padStart(2, '0');
            if (token.description) {
              lines.push(`/** ${token.description} */`);
            }
            lines.push(`inline const juce::Colour ${cppName} (0x${hex.toUpperCase()});`);
          }
        }
      }
      lines.push('');
    }
    
    const dimensionTokens = [...tokens.groups.dimension, ...tokens.groups.spacing];
    if (dimensionTokens.length > 0) {
      lines.push('// Dimensions');
      for (const token of dimensionTokens) {
        const cppName = 'k' + toPascalCase(token.path.join('_'));
        const px = dimensionToPx(token.value);
        if (!isNaN(px)) {
          if (token.description) {
            lines.push(`/** ${token.description} */`);
          }
          lines.push(`inline constexpr float ${cppName} = ${px.toFixed(1)}f;`);
        }
      }
      lines.push('');
    }
    
    const typographyTokens = tokens.groups.typography;
    if (typographyTokens.length > 0) {
      lines.push('// Typography');
      for (const token of typographyTokens) {
        const cppName = 'k' + toPascalCase(token.path.join('_'));
        if (token.type === 'fontFamily') {
          lines.push(`inline const juce::String ${cppName} ("${token.value}");`);
        }
      }
      lines.push('');
    }
    
    lines.push('// LookAndFeel helper');
    lines.push('class ThemeLookAndFeel : public juce::LookAndFeel_V4 {');
    lines.push('public:');
    lines.push('    ThemeLookAndFeel() {');
    
    const bgColor = colorTokens.find(t => 
      t.path.some(p => p.toLowerCase().includes('background'))
    );
    const fgColor = colorTokens.find(t => 
      t.path.some(p => p.toLowerCase().includes('text') || p.toLowerCase().includes('foreground'))
    );
    
    if (bgColor) {
      const cppName = 'k' + toPascalCase(bgColor.path.join('_'));
      lines.push(`        setColour(juce::ResizableWindow::backgroundColourId, ${cppName});`);
    }
    if (fgColor) {
      const cppName = 'k' + toPascalCase(fgColor.path.join('_'));
      lines.push(`        setColour(juce::Label::textColourId, ${cppName});`);
    }
    
    lines.push('    }');
    lines.push('};');
    lines.push('');
    
    if (useNamespace) {
      lines.push(`} // namespace ${namespace}`);
      lines.push('');
    }
    
    lines.push(`#endif // ${guard}`);
    
    return lines.join('\n');
  },
};
