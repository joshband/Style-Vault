/**
 * Unity C# Theme Exporter
 * 
 * Exports tokens as C# ScriptableObject for Unity game development.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, toPascalCase, sanitizeJsName, parseColor, colorToUnity, dimensionToPx } from '../token-pipeline';

export const exportUnity: ExporterDefinition = {
  id: 'unity',
  name: 'Unity (C#)',
  description: 'C# ScriptableObject theme for Unity game UI development.',
  category: 'game-engine',
  extension: 'cs',
  mimeType: 'text/x-csharp',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'useScriptableObject',
      label: 'Generate ScriptableObject',
      type: 'boolean',
      default: true,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const useScriptableObject = options?.useScriptableObject ?? true;
    const className = toPascalCase(sanitizeJsName(tokens.name)) + 'Theme' || 'AppTheme';
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// Unity compatible theme`,
      '',
      'using UnityEngine;',
      '',
    ];
    
    if (useScriptableObject) {
      lines.push(`[CreateAssetMenu(fileName = "${className}", menuName = "Themes/${className}")]`);
      lines.push(`public class ${className} : ScriptableObject`);
    } else {
      lines.push(`public static class ${className}`);
    }
    lines.push('{');
    
    const colorTokens = tokens.groups.color;
    if (colorTokens.length > 0) {
      lines.push('    [Header("Colors")]');
      for (const token of colorTokens) {
        const csharpName = toCamelCase(token.path.join('_'));
        if (typeof token.value === 'string') {
          const parsed = parseColor(token.value);
          if (parsed) {
            const unityColor = colorToUnity(parsed);
            if (useScriptableObject) {
              if (token.description) {
                lines.push(`    [Tooltip("${token.description}")]`);
              }
              lines.push(`    public Color ${csharpName} = ${unityColor};`);
            } else {
              if (token.description) {
                lines.push(`    /// <summary>${token.description}</summary>`);
              }
              lines.push(`    public static readonly Color ${csharpName} = ${unityColor};`);
            }
          }
        }
      }
      lines.push('');
    }
    
    const dimensionTokens = [...tokens.groups.dimension, ...tokens.groups.spacing];
    if (dimensionTokens.length > 0) {
      lines.push('    [Header("Dimensions")]');
      for (const token of dimensionTokens) {
        const csharpName = toCamelCase(token.path.join('_'));
        const px = dimensionToPx(token.value);
        if (!isNaN(px)) {
          if (useScriptableObject) {
            if (token.description) {
              lines.push(`    [Tooltip("${token.description}")]`);
            }
            lines.push(`    public float ${csharpName} = ${px}f;`);
          } else {
            lines.push(`    public static readonly float ${csharpName} = ${px}f;`);
          }
        }
      }
      lines.push('');
    }
    
    const typographyTokens = tokens.groups.typography;
    if (typographyTokens.length > 0) {
      lines.push('    [Header("Typography")]');
      for (const token of typographyTokens) {
        const csharpName = toCamelCase(token.path.join('_'));
        if (token.type === 'fontFamily') {
          if (useScriptableObject) {
            lines.push(`    public string ${csharpName} = "${token.value}";`);
          } else {
            lines.push(`    public static readonly string ${csharpName} = "${token.value}";`);
          }
        }
      }
    }
    
    lines.push('}');
    
    return lines.join('\n');
  },
};
