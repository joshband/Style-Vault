/**
 * Next.js Theme Bundle Exporter
 * 
 * Exports tokens as a Next.js-compatible theme with CSS variables and TypeScript types.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, sanitizeJsName, sanitizeCssName, parseColor, rgbaToCSS, dimensionToCSS } from '../token-pipeline';

export const exportNextJS: ExporterDefinition = {
  id: 'nextjs',
  name: 'Next.js Theme',
  description: 'Theme bundle for Next.js with CSS variables and TypeScript types.',
  category: 'web',
  extension: 'ts',
  mimeType: 'text/typescript',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'cssInJs',
      label: 'Include CSS-in-JS utilities',
      type: 'boolean',
      default: true,
    },
    {
      id: 'darkMode',
      label: 'Generate dark mode variant',
      type: 'boolean',
      default: false,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const cssInJs = options?.cssInJs ?? true;
    const themeName = toCamelCase(sanitizeJsName(tokens.name)) || 'theme';
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// Next.js Theme Bundle`,
      '',
      `/**`,
      ` * CSS Custom Properties as a string for injection`,
      ` * Usage: <style>{cssVariables}</style> or globals.css`,
      ` */`,
      `export const cssVariables = \``,
      `:root {`,
    ];
    
    for (const token of tokens.tokens) {
      const name = token.path.map(sanitizeCssName).join('-');
      const cssValue = formatCSSValue(token.value, token.type);
      lines.push(`  --${name}: ${cssValue};`);
    }
    
    lines.push('}`;\n');
    
    lines.push('/**');
    lines.push(' * Theme object with all token values');
    lines.push(' */');
    lines.push(`export const ${themeName} = {`);
    
    const colorTokens = tokens.groups.color;
    if (colorTokens.length > 0) {
      lines.push('  colors: {');
      for (const token of colorTokens) {
        const key = toCamelCase(token.path.join('_'));
        const cssVar = `--${token.path.map(sanitizeCssName).join('-')}`;
        lines.push(`    ${key}: "var(${cssVar})",`);
      }
      lines.push('  },');
    }
    
    const spacingTokens = [...tokens.groups.spacing, ...tokens.groups.dimension];
    if (spacingTokens.length > 0) {
      lines.push('  spacing: {');
      for (const token of spacingTokens) {
        const key = toCamelCase(token.path.join('_'));
        const cssVar = `--${token.path.map(sanitizeCssName).join('-')}`;
        lines.push(`    ${key}: "var(${cssVar})",`);
      }
      lines.push('  },');
    }
    
    const typographyTokens = tokens.groups.typography;
    if (typographyTokens.length > 0) {
      lines.push('  typography: {');
      for (const token of typographyTokens) {
        const key = toCamelCase(token.path.join('_'));
        const cssVar = `--${token.path.map(sanitizeCssName).join('-')}`;
        lines.push(`    ${key}: "var(${cssVar})",`);
      }
      lines.push('  },');
    }
    
    lines.push('} as const;');
    lines.push('');
    lines.push(`export type Theme = typeof ${themeName};`);
    lines.push('');
    
    if (cssInJs) {
      lines.push('/**');
      lines.push(' * CSS-in-JS utility for styled-components, emotion, etc.');
      lines.push(' */');
      lines.push('export const themeVars = {');
      
      for (const token of tokens.tokens) {
        const key = toCamelCase(token.path.join('_'));
        const cssVar = `--${token.path.map(sanitizeCssName).join('-')}`;
        lines.push(`  ${key}: \`var(${cssVar})\`,`);
      }
      
      lines.push('} as const;');
      lines.push('');
      
      lines.push('/**');
      lines.push(' * Raw token values (for server-side or non-CSS contexts)');
      lines.push(' */');
      lines.push('export const rawTokens = {');
      
      for (const token of tokens.tokens) {
        const key = toCamelCase(token.path.join('_'));
        const value = typeof token.value === 'string' ? `"${token.value}"` : token.value;
        lines.push(`  ${key}: ${value},`);
      }
      
      lines.push('} as const;');
      lines.push('');
    }
    
    lines.push('/**');
    lines.push(' * Inject theme CSS variables into document');
    lines.push(' */');
    lines.push('export function injectTheme(): void {');
    lines.push('  if (typeof document === "undefined") return;');
    lines.push('  ');
    lines.push('  let style = document.getElementById("visual-dna-theme");');
    lines.push('  if (!style) {');
    lines.push('    style = document.createElement("style");');
    lines.push('    style.id = "visual-dna-theme";');
    lines.push('    document.head.appendChild(style);');
    lines.push('  }');
    lines.push('  style.textContent = cssVariables;');
    lines.push('}');
    lines.push('');
    lines.push(`export default ${themeName};`);
    
    return lines.join('\n');
  },
};

function formatCSSValue(value: any, type: string): string {
  if (type === 'color' && typeof value === 'string') {
    const parsed = parseColor(value);
    if (parsed) {
      return rgbaToCSS(parsed);
    }
  }
  
  if (type === 'dimension') {
    return dimensionToCSS(value);
  }
  
  if (typeof value === 'string') {
    if (/^#[0-9a-fA-F]{3,8}$/.test(value)) return value;
    if (/^(rgb|hsl|oklch)/.test(value)) return value;
    if (/^-?\d+(\.\d+)?(px|rem|em|%|vw|vh|deg|s|ms)?$/.test(value)) return value;
    return value;
  }
  
  return String(value);
}
