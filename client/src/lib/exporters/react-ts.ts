/**
 * React TypeScript Theme Exporter
 * 
 * Exports tokens as a typed TypeScript theme object.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, toPascalCase, sanitizeJsName } from '../token-pipeline';

export const exportReactTS: ExporterDefinition = {
  id: 'react-ts',
  name: 'React / TypeScript',
  description: 'Typed theme object for React applications with full TypeScript support.',
  category: 'web',
  extension: 'ts',
  mimeType: 'text/typescript',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'exportStyle',
      label: 'Export style',
      type: 'select',
      default: 'const',
      options: [
        { value: 'const', label: 'const assertion (as const)' },
        { value: 'interface', label: 'Interface with values' },
      ],
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const themeName = toCamelCase(sanitizeJsName(tokens.name)) || 'theme';
    const typeName = toPascalCase(sanitizeJsName(tokens.name)) + 'Theme';
    
    const nested = buildNestedObject(tokens.tokens);
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// W3C DTCG compliant - ${tokens.metadata.exportedAt}`,
      '',
      `export const ${themeName} = ${formatTSObject(nested, 0)} as const;`,
      '',
      `export type ${typeName} = typeof ${themeName};`,
      '',
      `export default ${themeName};`,
    ];
    
    return lines.join('\n');
  },
};

function buildNestedObject(tokens: NormalizedTokenSet['tokens']): Record<string, any> {
  const result: Record<string, any> = {};
  
  for (const token of tokens) {
    let current = result;
    
    for (let i = 0; i < token.path.length - 1; i++) {
      const key = sanitizeJsName(token.path[i]);
      if (!current[key]) {
        current[key] = {};
      }
      current = current[key];
    }
    
    const finalKey = sanitizeJsName(token.path[token.path.length - 1]);
    current[finalKey] = token.value;
  }
  
  return result;
}

function formatTSObject(obj: any, indent: number): string {
  if (obj === null) return 'null';
  if (typeof obj !== 'object') {
    if (typeof obj === 'string') return `"${obj.replace(/"/g, '\\"')}"`;
    return String(obj);
  }
  
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]';
    const items = obj.map(item => formatTSObject(item, indent + 1));
    return `[${items.join(', ')}]`;
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) return '{}';
  
  const pad = '  '.repeat(indent + 1);
  const closePad = '  '.repeat(indent);
  
  const lines = entries.map(([key, value]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
    return `${pad}${safeKey}: ${formatTSObject(value, indent + 1)}`;
  });
  
  return `{\n${lines.join(',\n')}\n${closePad}}`;
}
