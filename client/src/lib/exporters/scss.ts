/**
 * SCSS Variables Exporter
 * 
 * Exports tokens as SCSS variables with optional CSS custom properties.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { sanitizeCssName, parseColor, rgbaToCSS, dimensionToCSS } from '../token-pipeline';

export const exportSCSS: ExporterDefinition = {
  id: 'scss',
  name: 'SCSS Variables',
  description: 'SCSS variables with optional CSS custom properties mixin.',
  category: 'web',
  extension: 'scss',
  mimeType: 'text/x-scss',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'includeCSSVars',
      label: 'Include CSS custom properties',
      type: 'boolean',
      default: true,
    },
    {
      id: 'generateMaps',
      label: 'Generate SCSS maps',
      type: 'boolean',
      default: false,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const includeCSSVars = options?.includeCSSVars ?? true;
    const generateMaps = options?.generateMaps ?? false;
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// W3C DTCG compliant - ${tokens.metadata.exportedAt}`,
      '',
    ];
    
    for (const token of tokens.tokens) {
      const name = token.path.map(sanitizeCssName).join('-');
      const value = formatSCSSValue(token.value, token.type);
      
      if (token.description) {
        lines.push(`// ${token.description}`);
      }
      lines.push(`$${name}: ${value};`);
    }
    
    if (generateMaps) {
      lines.push('');
      lines.push('// Token Maps');
      
      const colorTokens = tokens.groups.color;
      if (colorTokens.length > 0) {
        lines.push('$colors: (');
        for (const token of colorTokens) {
          const name = token.path.map(sanitizeCssName).join('-');
          lines.push(`  "${name}": $${name},`);
        }
        lines.push(');');
      }
      
      const spacingTokens = tokens.groups.spacing;
      if (spacingTokens.length > 0) {
        lines.push('');
        lines.push('$spacing: (');
        for (const token of spacingTokens) {
          const name = token.path.map(sanitizeCssName).join('-');
          lines.push(`  "${name}": $${name},`);
        }
        lines.push(');');
      }
    }
    
    if (includeCSSVars) {
      lines.push('');
      lines.push('// CSS Custom Properties');
      lines.push(':root {');
      
      for (const token of tokens.tokens) {
        const name = token.path.map(sanitizeCssName).join('-');
        lines.push(`  --${name}: $${name};`);
      }
      
      lines.push('}');
    }
    
    return lines.join('\n');
  },
};

function formatSCSSValue(value: any, type: string): string {
  if (type === 'color' && typeof value === 'string') {
    const parsed = parseColor(value);
    if (parsed) {
      return rgbaToCSS(parsed);
    }
  }
  
  if (type === 'dimension') {
    return dimensionToCSS(value);
  }
  
  if (typeof value === 'string') {
    if (/^#[0-9a-fA-F]{3,8}$/.test(value)) return value;
    if (/^(rgb|hsl|oklch)/.test(value)) return value;
    if (/^-?\d+(\.\d+)?(px|rem|em|%|vw|vh|deg|s|ms)?$/.test(value)) return value;
    return `"${value}"`;
  }
  
  if (typeof value === 'number') {
    return String(value);
  }
  
  return JSON.stringify(value);
}
