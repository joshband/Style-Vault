/**
 * Android XML Colors Exporter
 * 
 * Exports color tokens as Android colors.xml resource file.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toSnakeCase, parseColor, rgbaToHex, dimensionToPx } from '../token-pipeline';

export const exportAndroidXML: ExporterDefinition = {
  id: 'android-xml',
  name: 'Android XML',
  description: 'colors.xml and dimens.xml resource files for Android development.',
  category: 'mobile',
  extension: 'xml',
  mimeType: 'application/xml',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'resourceType',
      label: 'Resource type',
      type: 'select',
      default: 'colors',
      options: [
        { value: 'colors', label: 'Colors only' },
        { value: 'dimens', label: 'Dimensions only' },
        { value: 'all', label: 'All resources' },
      ],
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const resourceType = options?.resourceType ?? 'colors';
    
    const lines: string[] = [
      `<?xml version="1.0" encoding="utf-8"?>`,
      `<!-- Design Tokens: ${tokens.name} -->`,
      `<!-- Generated by Visual DNA Studio -->`,
      `<resources>`,
    ];
    
    if (resourceType === 'colors' || resourceType === 'all') {
      const colorTokens = tokens.groups.color;
      if (colorTokens.length > 0) {
        lines.push('    <!-- Colors -->');
        for (const token of colorTokens) {
          const name = toSnakeCase(token.path.join('_'));
          if (typeof token.value === 'string') {
            const parsed = parseColor(token.value);
            if (parsed) {
              const hex = rgbaToHex(parsed, true).toUpperCase();
              if (token.description) {
                lines.push(`    <!-- ${token.description} -->`);
              }
              lines.push(`    <color name="${name}">${hex}</color>`);
            }
          }
        }
      }
    }
    
    if (resourceType === 'dimens' || resourceType === 'all') {
      const dimensionTokens = [...tokens.groups.dimension, ...tokens.groups.spacing];
      if (dimensionTokens.length > 0) {
        if (resourceType === 'all') {
          lines.push('');
        }
        lines.push('    <!-- Dimensions -->');
        for (const token of dimensionTokens) {
          const name = toSnakeCase(token.path.join('_'));
          const px = dimensionToPx(token.value);
          if (!isNaN(px)) {
            const dp = Math.round(px);
            if (token.description) {
              lines.push(`    <!-- ${token.description} -->`);
            }
            lines.push(`    <dimen name="${name}">${dp}dp</dimen>`);
          }
        }
      }
    }
    
    lines.push('</resources>');
    
    return lines.join('\n');
  },
};
