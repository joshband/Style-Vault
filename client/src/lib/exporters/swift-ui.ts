/**
 * Swift/iOS Theme Exporter
 * 
 * Exports tokens as Swift code for iOS/macOS applications.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, toPascalCase, sanitizeJsName, parseColor, colorToSwiftUI, dimensionToPx } from '../token-pipeline';

export const exportSwiftUI: ExporterDefinition = {
  id: 'swift-ui',
  name: 'Swift / iOS',
  description: 'Swift theme extension for SwiftUI and UIKit applications.',
  category: 'mobile',
  extension: 'swift',
  mimeType: 'text/x-swift',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'framework',
      label: 'UI Framework',
      type: 'select',
      default: 'swiftui',
      options: [
        { value: 'swiftui', label: 'SwiftUI' },
        { value: 'uikit', label: 'UIKit' },
      ],
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const framework = options?.framework ?? 'swiftui';
    const themeName = toPascalCase(sanitizeJsName(tokens.name)) || 'AppTheme';
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// W3C DTCG compliant - ${tokens.metadata.exportedAt}`,
      '',
    ];
    
    if (framework === 'swiftui') {
      lines.push('import SwiftUI');
      lines.push('');
      lines.push(`enum ${themeName} {`);
      lines.push('');
      
      const colorTokens = tokens.groups.color;
      if (colorTokens.length > 0) {
        lines.push('    // MARK: - Colors');
        for (const token of colorTokens) {
          const swiftName = toCamelCase(token.path.join('_'));
          if (typeof token.value === 'string') {
            const parsed = parseColor(token.value);
            if (parsed) {
              const swiftColor = colorToSwiftUI(parsed);
              if (token.description) {
                lines.push(`    /// ${token.description}`);
              }
              lines.push(`    static let ${swiftName} = ${swiftColor}`);
            }
          }
        }
        lines.push('');
      }
      
      const dimensionTokens = [...tokens.groups.dimension, ...tokens.groups.spacing];
      if (dimensionTokens.length > 0) {
        lines.push('    // MARK: - Dimensions');
        for (const token of dimensionTokens) {
          const swiftName = toCamelCase(token.path.join('_'));
          const px = dimensionToPx(token.value);
          if (!isNaN(px)) {
            if (token.description) {
              lines.push(`    /// ${token.description}`);
            }
            lines.push(`    static let ${swiftName}: CGFloat = ${px}`);
          }
        }
        lines.push('');
      }
      
      const typographyTokens = tokens.groups.typography;
      if (typographyTokens.length > 0) {
        lines.push('    // MARK: - Typography');
        for (const token of typographyTokens) {
          const swiftName = toCamelCase(token.path.join('_'));
          if (token.type === 'fontFamily') {
            lines.push(`    static let ${swiftName} = "${token.value}"`);
          }
        }
        lines.push('');
      }
      
      lines.push('}');
    } else {
      lines.push('import UIKit');
      lines.push('');
      lines.push(`enum ${themeName} {`);
      lines.push('');
      
      const colorTokens = tokens.groups.color;
      if (colorTokens.length > 0) {
        lines.push('    // MARK: - Colors');
        for (const token of colorTokens) {
          const swiftName = toCamelCase(token.path.join('_'));
          if (typeof token.value === 'string') {
            const parsed = parseColor(token.value);
            if (parsed) {
              const r = (parsed.r / 255).toFixed(3);
              const g = (parsed.g / 255).toFixed(3);
              const b = (parsed.b / 255).toFixed(3);
              const a = parsed.a.toFixed(3);
              if (token.description) {
                lines.push(`    /// ${token.description}`);
              }
              lines.push(`    static let ${swiftName} = UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`);
            }
          }
        }
        lines.push('');
      }
      
      const dimensionTokens = [...tokens.groups.dimension, ...tokens.groups.spacing];
      if (dimensionTokens.length > 0) {
        lines.push('    // MARK: - Dimensions');
        for (const token of dimensionTokens) {
          const swiftName = toCamelCase(token.path.join('_'));
          const px = dimensionToPx(token.value);
          if (!isNaN(px)) {
            lines.push(`    static let ${swiftName}: CGFloat = ${px}`);
          }
        }
        lines.push('');
      }
      
      lines.push('}');
    }
    
    return lines.join('\n');
  },
};
