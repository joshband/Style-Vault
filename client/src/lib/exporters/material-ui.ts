/**
 * Material UI Theme Exporter
 * 
 * Exports tokens as Material UI theme configuration.
 */

import type { ExporterDefinition, NormalizedTokenSet } from '../token-pipeline';
import { toCamelCase, sanitizeJsName, dimensionToPx } from '../token-pipeline';

export const exportMaterialUI: ExporterDefinition = {
  id: 'material-ui',
  name: 'Material UI',
  description: 'Theme configuration for Material UI (MUI) v5+ React applications.',
  category: 'web',
  extension: 'ts',
  mimeType: 'text/typescript',
  isBinary: false,
  serverSide: false,
  subOptions: [
    {
      id: 'includeTypography',
      label: 'Include typography config',
      type: 'boolean',
      default: true,
    },
  ],
  export: (tokens: NormalizedTokenSet, options?: Record<string, any>): string => {
    const includeTypography = options?.includeTypography ?? true;
    
    const lines: string[] = [
      `// Design Tokens: ${tokens.name}`,
      `// Generated by Visual DNA Studio`,
      `// Material UI v5+ theme configuration`,
      '',
      "import { createTheme, ThemeOptions } from '@mui/material/styles';",
      '',
    ];
    
    const palette = buildPalette(tokens.groups.color);
    const spacing = buildSpacing(tokens.groups.spacing, tokens.groups.dimension);
    const typography = includeTypography ? buildTypography(tokens.groups.typography) : null;
    
    lines.push('const themeOptions: ThemeOptions = {');
    
    if (Object.keys(palette).length > 0) {
      lines.push(`  palette: ${formatMUIObject(palette, 2)},`);
    }
    
    if (spacing.baseUnit) {
      lines.push(`  spacing: ${spacing.baseUnit},`);
    }
    
    if (typography && Object.keys(typography).length > 0) {
      lines.push(`  typography: ${formatMUIObject(typography, 2)},`);
    }
    
    lines.push('};');
    lines.push('');
    lines.push('export const theme = createTheme(themeOptions);');
    lines.push('');
    lines.push('export default theme;');
    
    return lines.join('\n');
  },
};

function buildPalette(colorTokens: NormalizedTokenSet['tokens']): Record<string, any> {
  const palette: Record<string, any> = {};
  
  for (const token of colorTokens) {
    const pathStr = token.path.join('.').toLowerCase();
    
    if (pathStr.includes('primary')) {
      if (!palette.primary) palette.primary = {};
      if (pathStr.includes('main') || pathStr.includes('default')) {
        palette.primary.main = token.value;
      } else if (pathStr.includes('light')) {
        palette.primary.light = token.value;
      } else if (pathStr.includes('dark')) {
        palette.primary.dark = token.value;
      } else if (pathStr.includes('contrast')) {
        palette.primary.contrastText = token.value;
      } else if (!palette.primary.main) {
        palette.primary.main = token.value;
      }
    } else if (pathStr.includes('secondary')) {
      if (!palette.secondary) palette.secondary = {};
      if (pathStr.includes('main') || pathStr.includes('default')) {
        palette.secondary.main = token.value;
      } else if (pathStr.includes('light')) {
        palette.secondary.light = token.value;
      } else if (pathStr.includes('dark')) {
        palette.secondary.dark = token.value;
      } else if (!palette.secondary.main) {
        palette.secondary.main = token.value;
      }
    } else if (pathStr.includes('error')) {
      if (!palette.error) palette.error = {};
      palette.error.main = token.value;
    } else if (pathStr.includes('warning')) {
      if (!palette.warning) palette.warning = {};
      palette.warning.main = token.value;
    } else if (pathStr.includes('success')) {
      if (!palette.success) palette.success = {};
      palette.success.main = token.value;
    } else if (pathStr.includes('info')) {
      if (!palette.info) palette.info = {};
      palette.info.main = token.value;
    } else if (pathStr.includes('background')) {
      if (!palette.background) palette.background = {};
      if (pathStr.includes('paper')) {
        palette.background.paper = token.value;
      } else {
        palette.background.default = token.value;
      }
    } else if (pathStr.includes('text')) {
      if (!palette.text) palette.text = {};
      if (pathStr.includes('primary')) {
        palette.text.primary = token.value;
      } else if (pathStr.includes('secondary')) {
        palette.text.secondary = token.value;
      } else if (pathStr.includes('disabled')) {
        palette.text.disabled = token.value;
      }
    }
  }
  
  return palette;
}

function buildSpacing(
  spacingTokens: NormalizedTokenSet['tokens'],
  dimensionTokens: NormalizedTokenSet['tokens']
): { baseUnit?: number } {
  const allTokens = [...spacingTokens, ...dimensionTokens];
  
  const baseToken = allTokens.find(t => 
    t.path.some(p => p.toLowerCase().includes('base') || p.toLowerCase().includes('unit'))
  );
  
  if (baseToken) {
    const px = dimensionToPx(baseToken.value);
    if (!isNaN(px)) {
      return { baseUnit: px };
    }
  }
  
  return {};
}

function buildTypography(typographyTokens: NormalizedTokenSet['tokens']): Record<string, any> {
  const typography: Record<string, any> = {};
  
  for (const token of typographyTokens) {
    if (token.type === 'fontFamily') {
      const key = toCamelCase(token.path.join('_'));
      if (key.toLowerCase().includes('heading') || key.toLowerCase().includes('display')) {
        typography.h1 = { fontFamily: token.value };
      } else if (key.toLowerCase().includes('body')) {
        typography.body1 = { fontFamily: token.value };
      } else {
        typography.fontFamily = token.value;
      }
    }
  }
  
  return typography;
}

function formatMUIObject(obj: any, indent: number): string {
  if (obj === null) return 'null';
  if (typeof obj !== 'object') {
    if (typeof obj === 'string') return `"${obj.replace(/"/g, '\\"')}"`;
    return String(obj);
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) return '{}';
  
  const pad = '  '.repeat(indent + 1);
  const closePad = '  '.repeat(indent);
  
  const lines = entries.map(([key, value]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
    return `${pad}${safeKey}: ${formatMUIObject(value, indent + 1)}`;
  });
  
  return `{\n${lines.join(',\n')}\n${closePad}}`;
}
