export type ExportFormat = 'json' | 'css' | 'scss' | 'react' | 'tailwind' | 'flutter';

export interface ExportOption {
  format: ExportFormat;
  label: string;
  extension: string;
  mimeType: string;
}

export const EXPORT_OPTIONS: ExportOption[] = [
  { format: 'json', label: 'W3C JSON (DTCG)', extension: 'tokens.json', mimeType: 'application/json' },
  { format: 'css', label: 'CSS Variables', extension: 'css', mimeType: 'text/css' },
  { format: 'scss', label: 'SCSS Variables', extension: 'scss', mimeType: 'text/x-scss' },
  { format: 'react', label: 'React/TypeScript', extension: 'ts', mimeType: 'text/typescript' },
  { format: 'tailwind', label: 'Tailwind Config', extension: 'js', mimeType: 'text/javascript' },
  { format: 'flutter', label: 'Flutter/Dart', extension: 'dart', mimeType: 'text/x-dart' },
];

function getTokenValue(token: any): any {
  if (token && typeof token === 'object' && '$value' in token) {
    return token.$value;
  }
  return token;
}

function sanitizeCssName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

function sanitizeJsName(name: string): string {
  const cleaned = name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
  if (/^[0-9]/.test(cleaned)) {
    return '_' + cleaned;
  }
  return cleaned;
}

function toCamelCase(name: string): string {
  return name
    .split(/[-_\s.]+/)
    .map((word, i) => i === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function toPascalCase(name: string): string {
  return name
    .split(/[-_\s.]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

interface FlatToken {
  path: string[];
  value: any;
  type?: string;
}

function flattenTokens(tokens: Record<string, any>, prefix: string[] = []): FlatToken[] {
  const result: FlatToken[] = [];
  
  for (const [key, value] of Object.entries(tokens)) {
    const currentPath = [...prefix, key];
    
    if (value && typeof value === 'object') {
      if ('$value' in value) {
        result.push({
          path: currentPath,
          value: value.$value,
          type: value.$type,
        });
      } else {
        result.push(...flattenTokens(value, currentPath));
      }
    } else {
      result.push({
        path: currentPath,
        value,
      });
    }
  }
  
  return result;
}

export function exportToJSON(tokens: Record<string, any>, styleName: string): string {
  return JSON.stringify(tokens, null, 2);
}

export function exportToCSS(tokens: Record<string, any>, styleName: string): string {
  const flat = flattenTokens(tokens);
  const lines: string[] = [
    `/* Design Tokens: ${styleName} */`,
    `/* Generated by Visual DNA */`,
    '',
    ':root {',
  ];
  
  for (const { path, value } of flat) {
    const name = path.map(sanitizeCssName).join('-');
    const cssValue = formatCssValue(value);
    lines.push(`  --${name}: ${cssValue};`);
  }
  
  lines.push('}');
  return lines.join('\n');
}

export function exportToSCSS(tokens: Record<string, any>, styleName: string): string {
  const flat = flattenTokens(tokens);
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    '',
  ];
  
  for (const { path, value } of flat) {
    const name = path.map(sanitizeCssName).join('-');
    const cssValue = formatCssValue(value);
    lines.push(`$${name}: ${cssValue};`);
  }
  
  lines.push('');
  lines.push('// CSS Custom Properties');
  lines.push(':root {');
  
  for (const { path } of flat) {
    const name = path.map(sanitizeCssName).join('-');
    lines.push(`  --${name}: $${name};`);
  }
  
  lines.push('}');
  return lines.join('\n');
}

function formatCssValue(value: any): string {
  if (typeof value === 'string') {
    if (/^#[0-9a-fA-F]{3,8}$/.test(value)) return value;
    if (/^(rgb|hsl|oklch)/.test(value)) return value;
    if (/^-?\d+(\.\d+)?(px|rem|em|%|vw|vh|deg|s|ms)?$/.test(value)) return value;
    return `"${value}"`;
  }
  if (typeof value === 'number') {
    return String(value);
  }
  return JSON.stringify(value);
}

export function exportToReact(tokens: Record<string, any>, styleName: string): string {
  const themeObj = buildNestedObject(tokens);
  const safeName = toCamelCase(sanitizeJsName(styleName)) || 'theme';
  
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    '',
    `export const ${safeName} = ${formatJsObject(themeObj, 0)} as const;`,
    '',
    `export type ${toPascalCase(safeName)}Theme = typeof ${safeName};`,
    '',
    `export default ${safeName};`,
  ];
  
  return lines.join('\n');
}

function buildNestedObject(tokens: Record<string, any>): any {
  const result: Record<string, any> = {};
  
  for (const [key, value] of Object.entries(tokens)) {
    const safeKey = sanitizeJsName(key);
    
    if (value && typeof value === 'object') {
      if ('$value' in value) {
        result[safeKey] = value.$value;
      } else {
        result[safeKey] = buildNestedObject(value);
      }
    } else {
      result[safeKey] = value;
    }
  }
  
  return result;
}

function formatJsObject(obj: any, indent: number): string {
  if (obj === null) return 'null';
  if (typeof obj !== 'object') {
    if (typeof obj === 'string') return `"${obj.replace(/"/g, '\\"')}"`;
    return String(obj);
  }
  
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]';
    const items = obj.map(item => formatJsObject(item, indent + 1));
    return `[${items.join(', ')}]`;
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) return '{}';
  
  const pad = '  '.repeat(indent + 1);
  const closePad = '  '.repeat(indent);
  
  const lines = entries.map(([key, value]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
    return `${pad}${safeKey}: ${formatJsObject(value, indent + 1)}`;
  });
  
  return `{\n${lines.join(',\n')}\n${closePad}}`;
}

export function exportToTailwind(tokens: Record<string, any>, styleName: string): string {
  const colors = extractColorTokens(tokens);
  const spacing = extractSpacingTokens(tokens);
  const typography = extractTypographyTokens(tokens);
  
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    `// Add this to your tailwind.config.js theme.extend`,
    '',
    'module.exports = {',
    '  theme: {',
    '    extend: {',
  ];
  
  if (Object.keys(colors).length > 0) {
    lines.push('      colors: ' + formatJsObject(colors, 3) + ',');
  }
  
  if (Object.keys(spacing).length > 0) {
    lines.push('      spacing: ' + formatJsObject(spacing, 3) + ',');
  }
  
  if (typography.fontFamily && Object.keys(typography.fontFamily).length > 0) {
    lines.push('      fontFamily: ' + formatJsObject(typography.fontFamily, 3) + ',');
  }
  
  if (typography.fontSize && Object.keys(typography.fontSize).length > 0) {
    lines.push('      fontSize: ' + formatJsObject(typography.fontSize, 3) + ',');
  }
  
  lines.push('    },');
  lines.push('  },');
  lines.push('};');
  
  return lines.join('\n');
}

function extractColorTokens(tokens: Record<string, any>): Record<string, any> {
  const colors: Record<string, any> = {};
  const colorSection = tokens.color || {};
  
  const traverse = (obj: any, target: Record<string, any>) => {
    for (const [key, value] of Object.entries(obj)) {
      const safeKey = sanitizeJsName(key);
      if (value && typeof value === 'object') {
        if ('$value' in value && typeof value.$value === 'string') {
          target[safeKey] = value.$value;
        } else if (!('$value' in value)) {
          target[safeKey] = {};
          traverse(value, target[safeKey]);
        }
      } else if (typeof value === 'string') {
        target[safeKey] = value;
      }
    }
  };
  
  traverse(colorSection, colors);
  return colors;
}

function extractSpacingTokens(tokens: Record<string, any>): Record<string, string> {
  const spacing: Record<string, string> = {};
  const spacingSection = tokens.spacing || {};
  
  const traverse = (obj: any, prefix = '') => {
    for (const [key, value] of Object.entries(obj)) {
      const name = prefix ? `${prefix}-${key}` : key;
      const safeKey = sanitizeJsName(name);
      
      if (value && typeof value === 'object' && '$value' in value) {
        spacing[safeKey] = String(value.$value);
      } else if (typeof value === 'string' || typeof value === 'number') {
        spacing[safeKey] = String(value);
      } else if (value && typeof value === 'object') {
        traverse(value, name);
      }
    }
  };
  
  traverse(spacingSection);
  return spacing;
}

function extractTypographyTokens(tokens: Record<string, any>): { fontFamily: Record<string, string[]>; fontSize: Record<string, string> } {
  const result = {
    fontFamily: {} as Record<string, string[]>,
    fontSize: {} as Record<string, string>,
  };
  
  const typoSection = tokens.typography || {};
  
  const traverse = (obj: any, prefix = '') => {
    for (const [key, value] of Object.entries(obj)) {
      const name = prefix ? `${prefix}-${key}` : key;
      const safeKey = sanitizeJsName(name);
      
      if (value && typeof value === 'object' && '$value' in value) {
        const val = (value as any).$value;
        const type = (value as any).$type;
        
        if (type === 'fontFamily' || key.toLowerCase().includes('family')) {
          result.fontFamily[safeKey] = [String(val)];
        } else if (type === 'fontSize' || type === 'dimension' || key.toLowerCase().includes('size')) {
          result.fontSize[safeKey] = String(val);
        }
      } else if (value && typeof value === 'object') {
        traverse(value, name);
      }
    }
  };
  
  traverse(typoSection);
  return result;
}

export function exportToFlutter(tokens: Record<string, any>, styleName: string): string {
  const className = toPascalCase(sanitizeJsName(styleName)) || 'AppTheme';
  const colors = extractColorTokens(tokens);
  const spacing = extractSpacingTokens(tokens);
  
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    '',
    "import 'package:flutter/material.dart';",
    '',
    `class ${className} {`,
    `  ${className}._();`,
    '',
  ];
  
  if (Object.keys(colors).length > 0) {
    lines.push('  // Colors');
    for (const [key, value] of Object.entries(flattenForDart(colors))) {
      const dartName = toCamelCase(key);
      const colorValue = formatDartColor(value);
      if (colorValue) {
        lines.push(`  static const Color ${dartName} = ${colorValue};`);
      }
    }
    lines.push('');
  }
  
  if (Object.keys(spacing).length > 0) {
    lines.push('  // Spacing');
    for (const [key, value] of Object.entries(spacing)) {
      const dartName = toCamelCase(key);
      const numValue = parseFloat(String(value));
      if (!isNaN(numValue)) {
        lines.push(`  static const double ${dartName} = ${numValue};`);
      }
    }
    lines.push('');
  }
  
  lines.push('}');
  return lines.join('\n');
}

function flattenForDart(obj: Record<string, any>, prefix = ''): Record<string, string> {
  const result: Record<string, string> = {};
  
  for (const [key, value] of Object.entries(obj)) {
    const name = prefix ? `${prefix}_${key}` : key;
    
    if (typeof value === 'string') {
      result[name] = value;
    } else if (typeof value === 'object' && value !== null) {
      Object.assign(result, flattenForDart(value, name));
    }
  }
  
  return result;
}

function formatDartColor(value: string): string | null {
  const hex = value.replace('#', '');
  
  if (/^[0-9a-fA-F]{6}$/.test(hex)) {
    return `Color(0xFF${hex.toUpperCase()})`;
  }
  if (/^[0-9a-fA-F]{8}$/.test(hex)) {
    return `Color(0x${hex.toUpperCase()})`;
  }
  if (/^[0-9a-fA-F]{3}$/.test(hex)) {
    const expanded = hex.split('').map(c => c + c).join('');
    return `Color(0xFF${expanded.toUpperCase()})`;
  }
  
  return null;
}

export function exportTokens(tokens: Record<string, any>, styleName: string, format: ExportFormat): string {
  switch (format) {
    case 'json':
      return exportToJSON(tokens, styleName);
    case 'css':
      return exportToCSS(tokens, styleName);
    case 'scss':
      return exportToSCSS(tokens, styleName);
    case 'react':
      return exportToReact(tokens, styleName);
    case 'tailwind':
      return exportToTailwind(tokens, styleName);
    case 'flutter':
      return exportToFlutter(tokens, styleName);
    default:
      return exportToJSON(tokens, styleName);
  }
}

export function downloadExport(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
