export type ExportFormat = 'json' | 'css' | 'scss' | 'react' | 'tailwind' | 'flutter' | 'figma' | 'adobe-xd';

export interface ExportOption {
  format: ExportFormat;
  label: string;
  extension: string;
  mimeType: string;
}

export const EXPORT_OPTIONS: ExportOption[] = [
  { format: 'json', label: 'W3C JSON (DTCG)', extension: 'tokens.json', mimeType: 'application/json' },
  { format: 'css', label: 'CSS Variables', extension: 'css', mimeType: 'text/css' },
  { format: 'scss', label: 'SCSS Variables', extension: 'scss', mimeType: 'text/x-scss' },
  { format: 'react', label: 'React/TypeScript', extension: 'ts', mimeType: 'text/typescript' },
  { format: 'tailwind', label: 'Tailwind Config', extension: 'js', mimeType: 'text/javascript' },
  { format: 'flutter', label: 'Flutter/Dart', extension: 'dart', mimeType: 'text/x-dart' },
  { format: 'figma', label: 'Figma Variables', extension: 'json', mimeType: 'application/json' },
  { format: 'adobe-xd', label: 'Adobe XD', extension: 'json', mimeType: 'application/json' },
];

function getTokenValue(token: any): any {
  if (token && typeof token === 'object' && '$value' in token) {
    return token.$value;
  }
  return token;
}

function sanitizeCssName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

function sanitizeJsName(name: string): string {
  const cleaned = name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
  if (/^[0-9]/.test(cleaned)) {
    return '_' + cleaned;
  }
  return cleaned;
}

function toCamelCase(name: string): string {
  return name
    .split(/[-_\s.]+/)
    .map((word, i) => i === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function toPascalCase(name: string): string {
  return name
    .split(/[-_\s.]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

interface FlatToken {
  path: string[];
  value: any;
  type?: string;
}

function flattenTokens(tokens: Record<string, any>, prefix: string[] = []): FlatToken[] {
  const result: FlatToken[] = [];
  
  for (const [key, value] of Object.entries(tokens)) {
    const currentPath = [...prefix, key];
    
    if (value && typeof value === 'object') {
      if ('$value' in value) {
        result.push({
          path: currentPath,
          value: value.$value,
          type: value.$type,
        });
      } else {
        result.push(...flattenTokens(value, currentPath));
      }
    } else {
      result.push({
        path: currentPath,
        value,
      });
    }
  }
  
  return result;
}

export function exportToJSON(tokens: Record<string, any>, styleName: string): string {
  return JSON.stringify(tokens, null, 2);
}

export function exportToCSS(tokens: Record<string, any>, styleName: string): string {
  const flat = flattenTokens(tokens);
  const lines: string[] = [
    `/* Design Tokens: ${styleName} */`,
    `/* Generated by Visual DNA */`,
    '',
    ':root {',
  ];
  
  for (const { path, value } of flat) {
    const name = path.map(sanitizeCssName).join('-');
    const cssValue = formatCssValue(value);
    lines.push(`  --${name}: ${cssValue};`);
  }
  
  lines.push('}');
  return lines.join('\n');
}

export function exportToSCSS(tokens: Record<string, any>, styleName: string): string {
  const flat = flattenTokens(tokens);
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    '',
  ];
  
  for (const { path, value } of flat) {
    const name = path.map(sanitizeCssName).join('-');
    const cssValue = formatCssValue(value);
    lines.push(`$${name}: ${cssValue};`);
  }
  
  lines.push('');
  lines.push('// CSS Custom Properties');
  lines.push(':root {');
  
  for (const { path } of flat) {
    const name = path.map(sanitizeCssName).join('-');
    lines.push(`  --${name}: $${name};`);
  }
  
  lines.push('}');
  return lines.join('\n');
}

function formatCssValue(value: any): string {
  if (typeof value === 'string') {
    if (/^#[0-9a-fA-F]{3,8}$/.test(value)) return value;
    if (/^(rgb|hsl|oklch)/.test(value)) return value;
    if (/^-?\d+(\.\d+)?(px|rem|em|%|vw|vh|deg|s|ms)?$/.test(value)) return value;
    return `"${value}"`;
  }
  if (typeof value === 'number') {
    return String(value);
  }
  return JSON.stringify(value);
}

export function exportToReact(tokens: Record<string, any>, styleName: string): string {
  const themeObj = buildNestedObject(tokens);
  const safeName = toCamelCase(sanitizeJsName(styleName)) || 'theme';
  
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    '',
    `export const ${safeName} = ${formatJsObject(themeObj, 0)} as const;`,
    '',
    `export type ${toPascalCase(safeName)}Theme = typeof ${safeName};`,
    '',
    `export default ${safeName};`,
  ];
  
  return lines.join('\n');
}

function buildNestedObject(tokens: Record<string, any>): any {
  const result: Record<string, any> = {};
  
  for (const [key, value] of Object.entries(tokens)) {
    const safeKey = sanitizeJsName(key);
    
    if (value && typeof value === 'object') {
      if ('$value' in value) {
        result[safeKey] = value.$value;
      } else {
        result[safeKey] = buildNestedObject(value);
      }
    } else {
      result[safeKey] = value;
    }
  }
  
  return result;
}

function formatJsObject(obj: any, indent: number): string {
  if (obj === null) return 'null';
  if (typeof obj !== 'object') {
    if (typeof obj === 'string') return `"${obj.replace(/"/g, '\\"')}"`;
    return String(obj);
  }
  
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]';
    const items = obj.map(item => formatJsObject(item, indent + 1));
    return `[${items.join(', ')}]`;
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) return '{}';
  
  const pad = '  '.repeat(indent + 1);
  const closePad = '  '.repeat(indent);
  
  const lines = entries.map(([key, value]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `"${key}"`;
    return `${pad}${safeKey}: ${formatJsObject(value, indent + 1)}`;
  });
  
  return `{\n${lines.join(',\n')}\n${closePad}}`;
}

export function exportToTailwind(tokens: Record<string, any>, styleName: string): string {
  const colors = extractColorTokens(tokens);
  const spacing = extractSpacingTokens(tokens);
  const typography = extractTypographyTokens(tokens);
  
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    `// Add this to your tailwind.config.js theme.extend`,
    '',
    'module.exports = {',
    '  theme: {',
    '    extend: {',
  ];
  
  if (Object.keys(colors).length > 0) {
    lines.push('      colors: ' + formatJsObject(colors, 3) + ',');
  }
  
  if (Object.keys(spacing).length > 0) {
    lines.push('      spacing: ' + formatJsObject(spacing, 3) + ',');
  }
  
  if (typography.fontFamily && Object.keys(typography.fontFamily).length > 0) {
    lines.push('      fontFamily: ' + formatJsObject(typography.fontFamily, 3) + ',');
  }
  
  if (typography.fontSize && Object.keys(typography.fontSize).length > 0) {
    lines.push('      fontSize: ' + formatJsObject(typography.fontSize, 3) + ',');
  }
  
  lines.push('    },');
  lines.push('  },');
  lines.push('};');
  
  return lines.join('\n');
}

function extractColorTokens(tokens: Record<string, any>): Record<string, any> {
  const colors: Record<string, any> = {};
  const colorSection = tokens.color || {};
  
  const traverse = (obj: any, target: Record<string, any>) => {
    for (const [key, value] of Object.entries(obj)) {
      const safeKey = sanitizeJsName(key);
      if (value && typeof value === 'object') {
        if ('$value' in value && typeof value.$value === 'string') {
          target[safeKey] = value.$value;
        } else if (!('$value' in value)) {
          target[safeKey] = {};
          traverse(value, target[safeKey]);
        }
      } else if (typeof value === 'string') {
        target[safeKey] = value;
      }
    }
  };
  
  traverse(colorSection, colors);
  return colors;
}

function extractSpacingTokens(tokens: Record<string, any>): Record<string, string> {
  const spacing: Record<string, string> = {};
  const spacingSection = tokens.spacing || {};
  
  const traverse = (obj: any, prefix = '') => {
    for (const [key, value] of Object.entries(obj)) {
      const name = prefix ? `${prefix}-${key}` : key;
      const safeKey = sanitizeJsName(name);
      
      if (value && typeof value === 'object' && '$value' in value) {
        spacing[safeKey] = String(value.$value);
      } else if (typeof value === 'string' || typeof value === 'number') {
        spacing[safeKey] = String(value);
      } else if (value && typeof value === 'object') {
        traverse(value, name);
      }
    }
  };
  
  traverse(spacingSection);
  return spacing;
}

function extractTypographyTokens(tokens: Record<string, any>): { fontFamily: Record<string, string[]>; fontSize: Record<string, string> } {
  const result = {
    fontFamily: {} as Record<string, string[]>,
    fontSize: {} as Record<string, string>,
  };
  
  const typoSection = tokens.typography || {};
  
  const traverse = (obj: any, prefix = '') => {
    for (const [key, value] of Object.entries(obj)) {
      const name = prefix ? `${prefix}-${key}` : key;
      const safeKey = sanitizeJsName(name);
      
      if (value && typeof value === 'object' && '$value' in value) {
        const val = (value as any).$value;
        const type = (value as any).$type;
        
        if (type === 'fontFamily' || key.toLowerCase().includes('family')) {
          result.fontFamily[safeKey] = [String(val)];
        } else if (type === 'fontSize' || type === 'dimension' || key.toLowerCase().includes('size')) {
          result.fontSize[safeKey] = String(val);
        }
      } else if (value && typeof value === 'object') {
        traverse(value, name);
      }
    }
  };
  
  traverse(typoSection);
  return result;
}

export function exportToFigma(tokens: Record<string, any>, styleName: string): string {
  const variables: any[] = [];
  const collections: any[] = [];
  
  const collectionId = `collection_${Date.now()}`;
  const modeId = `mode_${Date.now()}`;
  
  collections.push({
    id: collectionId,
    name: styleName,
    modes: [{ modeId, name: 'Default' }],
    defaultModeId: modeId,
    remote: false,
    hiddenFromPublishing: false,
  });
  
  const addVariable = (path: string[], value: any, type: string) => {
    const variableId = `var_${path.join('_')}_${Date.now()}`;
    const name = path.join('/');
    
    let resolvedType = 'STRING';
    let resolvedValue = value;
    
    if (type === 'color' || (typeof value === 'string' && /^#|^rgb|^oklch/.test(value))) {
      resolvedType = 'COLOR';
      resolvedValue = hexToFigmaColor(value);
    } else if (type === 'dimension' || type === 'spacing' || type === 'borderRadius') {
      resolvedType = 'FLOAT';
      resolvedValue = parseFloat(String(value).replace(/[^\d.-]/g, '')) || 0;
    } else if (typeof value === 'number') {
      resolvedType = 'FLOAT';
      resolvedValue = value;
    } else if (typeof value === 'boolean') {
      resolvedType = 'BOOLEAN';
      resolvedValue = value;
    } else {
      resolvedType = 'STRING';
      resolvedValue = String(value);
    }
    
    variables.push({
      id: variableId,
      name,
      resolvedType,
      valuesByMode: {
        [modeId]: resolvedValue,
      },
      remote: false,
      description: '',
      hiddenFromPublishing: false,
      scopes: ['ALL_SCOPES'],
      codeSyntax: {},
    });
  };
  
  const traverse = (obj: any, path: string[] = []) => {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = [...path, key];
      
      if (value && typeof value === 'object') {
        if ('$value' in value) {
          const tokenObj = value as { $value: any; $type?: string };
          addVariable(currentPath, tokenObj.$value, tokenObj.$type || '');
        } else {
          traverse(value, currentPath);
        }
      } else {
        addVariable(currentPath, value, '');
      }
    }
  };
  
  traverse(tokens);
  
  const figmaExport = {
    version: '1.0',
    meta: {
      name: styleName,
      generator: 'Visual DNA',
      exportedAt: new Date().toISOString(),
    },
    variableCollections: collections,
    variables,
  };
  
  return JSON.stringify(figmaExport, null, 2);
}

function hexToFigmaColor(color: string): { r: number; g: number; b: number; a: number } {
  let r = 0, g = 0, b = 0, a = 1;
  
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    if (hex.length === 3) {
      r = parseInt(hex[0] + hex[0], 16) / 255;
      g = parseInt(hex[1] + hex[1], 16) / 255;
      b = parseInt(hex[2] + hex[2], 16) / 255;
    } else if (hex.length === 6) {
      r = parseInt(hex.slice(0, 2), 16) / 255;
      g = parseInt(hex.slice(2, 4), 16) / 255;
      b = parseInt(hex.slice(4, 6), 16) / 255;
    } else if (hex.length === 8) {
      r = parseInt(hex.slice(0, 2), 16) / 255;
      g = parseInt(hex.slice(2, 4), 16) / 255;
      b = parseInt(hex.slice(4, 6), 16) / 255;
      a = parseInt(hex.slice(6, 8), 16) / 255;
    }
  } else if (color.startsWith('rgb')) {
    const match = color.match(/[\d.]+/g);
    if (match) {
      r = parseFloat(match[0]) / 255;
      g = parseFloat(match[1]) / 255;
      b = parseFloat(match[2]) / 255;
      if (match[3]) a = parseFloat(match[3]);
    }
  }
  
  return { r, g, b, a };
}

export function exportToAdobeXD(tokens: Record<string, any>, styleName: string): string {
  const assets: any = {
    version: 1,
    meta: {
      name: styleName,
      generator: 'Visual DNA',
      exportedAt: new Date().toISOString(),
    },
    colors: [],
    characterStyles: [],
    components: [],
  };
  
  const colorTokens = tokens.color || {};
  const typographyTokens = tokens.typography || {};
  
  const extractColors = (obj: any, prefix = '') => {
    for (const [key, value] of Object.entries(obj)) {
      const name = prefix ? `${prefix}/${key}` : key;
      
      if (value && typeof value === 'object') {
        if ('$value' in value && typeof value.$value === 'string') {
          const colorValue = value.$value;
          const rgba = parseColorToRGBA(colorValue);
          if (rgba) {
            assets.colors.push({
              name,
              value: {
                mode: 'RGB',
                value: rgba,
                alpha: rgba.a,
              },
            });
          }
        } else {
          extractColors(value, name);
        }
      }
    }
  };
  
  const extractTypography = (obj: any, prefix = '') => {
    for (const [key, value] of Object.entries(obj)) {
      const name = prefix ? `${prefix}/${key}` : key;
      
      if (value && typeof value === 'object') {
        if ('$value' in value) {
          const tokenObj = value as { $value: any; $type?: string };
          const type = tokenObj.$type;
          const val = tokenObj.$value;
          
          if (type === 'fontFamily' || key.toLowerCase().includes('family')) {
            assets.characterStyles.push({
              name,
              style: {
                fontFamily: String(val),
              },
            });
          }
        } else {
          extractTypography(value, name);
        }
      }
    }
  };
  
  extractColors(colorTokens);
  extractTypography(typographyTokens);
  
  return JSON.stringify(assets, null, 2);
}

function parseColorToRGBA(color: string): { r: number; g: number; b: number; a: number } | null {
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    let r = 0, g = 0, b = 0, a = 255;
    
    if (hex.length === 3) {
      r = parseInt(hex[0] + hex[0], 16);
      g = parseInt(hex[1] + hex[1], 16);
      b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length === 6) {
      r = parseInt(hex.slice(0, 2), 16);
      g = parseInt(hex.slice(2, 4), 16);
      b = parseInt(hex.slice(4, 6), 16);
    } else if (hex.length === 8) {
      r = parseInt(hex.slice(0, 2), 16);
      g = parseInt(hex.slice(2, 4), 16);
      b = parseInt(hex.slice(4, 6), 16);
      a = parseInt(hex.slice(6, 8), 16);
    }
    
    return { r, g, b, a: a / 255 };
  } else if (color.startsWith('rgb')) {
    const match = color.match(/[\d.]+/g);
    if (match) {
      return {
        r: parseInt(match[0]),
        g: parseInt(match[1]),
        b: parseInt(match[2]),
        a: match[3] ? parseFloat(match[3]) : 1,
      };
    }
  }
  
  return null;
}

export function exportToFlutter(tokens: Record<string, any>, styleName: string): string {
  const className = toPascalCase(sanitizeJsName(styleName)) || 'AppTheme';
  const colors = extractColorTokens(tokens);
  const spacing = extractSpacingTokens(tokens);
  
  const lines: string[] = [
    `// Design Tokens: ${styleName}`,
    `// Generated by Visual DNA`,
    '',
    "import 'package:flutter/material.dart';",
    '',
    `class ${className} {`,
    `  ${className}._();`,
    '',
  ];
  
  if (Object.keys(colors).length > 0) {
    lines.push('  // Colors');
    for (const [key, value] of Object.entries(flattenForDart(colors))) {
      const dartName = toCamelCase(key);
      const colorValue = formatDartColor(value);
      if (colorValue) {
        lines.push(`  static const Color ${dartName} = ${colorValue};`);
      }
    }
    lines.push('');
  }
  
  if (Object.keys(spacing).length > 0) {
    lines.push('  // Spacing');
    for (const [key, value] of Object.entries(spacing)) {
      const dartName = toCamelCase(key);
      const numValue = parseFloat(String(value));
      if (!isNaN(numValue)) {
        lines.push(`  static const double ${dartName} = ${numValue};`);
      }
    }
    lines.push('');
  }
  
  lines.push('}');
  return lines.join('\n');
}

function flattenForDart(obj: Record<string, any>, prefix = ''): Record<string, string> {
  const result: Record<string, string> = {};
  
  for (const [key, value] of Object.entries(obj)) {
    const name = prefix ? `${prefix}_${key}` : key;
    
    if (typeof value === 'string') {
      result[name] = value;
    } else if (typeof value === 'object' && value !== null) {
      Object.assign(result, flattenForDart(value, name));
    }
  }
  
  return result;
}

function formatDartColor(value: string): string | null {
  const hex = value.replace('#', '');
  
  if (/^[0-9a-fA-F]{6}$/.test(hex)) {
    return `Color(0xFF${hex.toUpperCase()})`;
  }
  if (/^[0-9a-fA-F]{8}$/.test(hex)) {
    return `Color(0x${hex.toUpperCase()})`;
  }
  if (/^[0-9a-fA-F]{3}$/.test(hex)) {
    const expanded = hex.split('').map(c => c + c).join('');
    return `Color(0xFF${expanded.toUpperCase()})`;
  }
  
  return null;
}

export function exportTokens(tokens: Record<string, any>, styleName: string, format: ExportFormat): string {
  switch (format) {
    case 'json':
      return exportToJSON(tokens, styleName);
    case 'css':
      return exportToCSS(tokens, styleName);
    case 'scss':
      return exportToSCSS(tokens, styleName);
    case 'react':
      return exportToReact(tokens, styleName);
    case 'tailwind':
      return exportToTailwind(tokens, styleName);
    case 'flutter':
      return exportToFlutter(tokens, styleName);
    case 'figma':
      return exportToFigma(tokens, styleName);
    case 'adobe-xd':
      return exportToAdobeXD(tokens, styleName);
    default:
      return exportToJSON(tokens, styleName);
  }
}

export function downloadExport(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
